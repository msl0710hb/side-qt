name: Qt 6.9.2 源码编译 CI（自动识别 dayN 工程）
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build-and-run:
    strategy:
      matrix:
        os: [macos-latest, windows-latest, ubuntu-latest]
        include:
          # 三平台源码包配置（官方源码直链 100% 有效）
          - os: macos-latest
            qt_src: qt-everywhere-src-6.9.2.tar.xz
            extract_cmd: tar -xf
            qt_install_dir: ${{ github.workspace }}/qt-6.9.2-install
          - os: windows-latest
            qt_src: qt-everywhere-src-6.9.2.zip
            extract_cmd: unzip -q
            qt_install_dir: ${{ github.workspace }}\qt-6.9.2-install
          - os: ubuntu-latest
            qt_src: qt-everywhere-src-6.9.2.tar.xz
            extract_cmd: tar -xf
            qt_install_dir: ${{ github.workspace }}/qt-6.9.2-install
    runs-on: ${{ matrix.os }}

    steps:
      - name: 检出项目源代码
        uses: actions/checkout@v4

      # 1. 安装基础编译依赖
      - name: 安装依赖（Ubuntu）
        if: matrix.os == 'ubuntu-latest'
        run: |
          sudo apt-get update -y
          sudo apt-get install -y \
            build-essential cmake ninja-build python3 \
            libgl1-mesa-dev libxkbcommon-dev libxkbcommon-x11-dev \
            libxcb-xinerama0-dev libxcb-icccm4-dev libxcb-keysyms1-dev \
            libxcb-image0-dev libxcb-util0-dev libxcb-xinput-dev \
            libxcb-xfixes0-dev libxcb-xkb-dev flex bison gperf \
            libicu-dev libxslt-dev ruby libssl-dev libfontconfig1-dev \
            libfreetype6-dev libx11-dev libxext-dev libxfixes-dev \
            libxi-dev libxrender-dev libxcb1-dev libx11-xcb-dev \
            libxcb-glx0-dev zlib1g-dev

      - name: 安装依赖（macOS）
        if: matrix.os == 'macos-latest'
        run: |
          brew install cmake ninja python3 pkg-config

      - name: 安装依赖（Windows）
        if: matrix.os == 'windows-latest'
        run: |
          choco install cmake ninja python3 -y
          echo "CMAKE_PREFIX_PATH=C:\Program Files\CMake\bin" >> $env:GITHUB_ENV

      # 2. 下载 Qt 6.9.2 源码包（官方直链，无 404）
      - name: 下载 Qt 6.9.2 源码
        run: |
          wget -c --tries=3 https://download.qt.io/archive/qt/6.9/6.9.2/${{ matrix.qt_src }} -O ${{ matrix.qt_src }} --timeout=600
          # 验证文件完整性（避免残缺）
          if [ "${{ matrix.os }}" != "windows-latest" ]; then
            FILE_SIZE=$(stat -c%s ${{ matrix.qt_src }} 2>/dev/null || stat -f%s ${{ matrix.qt_src }})
            if [ $FILE_SIZE -lt 1000000000 ]; then  # 小于 1G 则视为下载失败
              echo "Qt 源码包下载不完整！"
              exit 1
            fi
          fi

      # 3. 解压源码包
      - name: 解压 Qt 源码
        run: |
          ${{ matrix.extract_cmd }} ${{ matrix.qt_src }}
          cd qt-everywhere-src-6.9.2
          echo "QT_SRC_DIR=$(pwd)" >> $GITHUB_ENV

      # 4. 配置 Qt 编译（跳过示例/测试，加快速度）
      - name: 配置 Qt 编译（Linux/macOS）
        if: matrix.os != 'windows-latest'
        run: |
          cd ${{ env.QT_SRC_DIR }}
          ./configure \
            -prefix ${{ matrix.qt_install_dir }} \
            -release -opensource -confirm-license \
            -nomake examples -nomake tests -ninja \
            -skip qtwebengine  # 跳过 webengine，减少编译时间

      - name: 配置 Qt 编译（Windows）
        if: matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          cd $env:QT_SRC_DIR
          .\configure.bat `
            -prefix "${{ matrix.qt_install_dir }}" `
            -release -opensource -confirm-license `
            -nomake examples -nomake tests -ninja `
            -skip qtwebengine

      # 5. 编译 Qt 6.9.2（并行编译，加快速度）
      - name: 编译 Qt 6.9.2
        run: |
          cd ${{ env.QT_SRC_DIR }}
          cmake --build . --parallel $(nproc 2>/dev/null || echo 4)  # 自动适配 CPU 核心数

      # 6. 安装 Qt 到指定目录
      - name: 安装 Qt 6.9.2
        run: |
          cd ${{ env.QT_SRC_DIR }}
          cmake --install .

      # 7. 配置 Qt 环境变量（供项目构建使用）
      - name: 配置 Qt 环境
        run: |
          if [ "${{ matrix.os }}" == "windows-latest" ]; then
            echo "Qt6_DIR=${{ matrix.qt_install_dir }}\lib\cmake\Qt6" >> $env:GITHUB_ENV
            echo "${{ matrix.qt_install_dir }}\bin" >> $env:GITHUB_PATH
          else
            echo "Qt6_DIR=${{ matrix.qt_install_dir }}/lib/cmake/Qt6" >> $GITHUB_ENV
            echo "${{ matrix.qt_install_dir }}/bin" >> $GITHUB_PATH
          fi
          # 验证 Qt 环境
          qmake --version || { echo "Qt 环境配置失败！"; exit 1; }

      # 8. 自动识别所有 dayN 工程（无需手动修改）
      - name: 自动识别 dayN 工程
        id: find_projects
        shell: bash
        run: |
          PROJECTS=$(find . -maxdepth 1 -type d -name "day[0-9]*" | sed 's|^\./||' | sort -V)
          echo "PROJECTS=($PROJECTS)" >> $GITHUB_ENV
          echo "识别到的工程：$PROJECTS"

      # 9. 批量构建所有 dayN 工程
      - name: 批量构建所有工程
        shell: bash
        run: |
          PROJECTS=(${GITHUB_ENV#*PROJECTS=})
          # 选择对应平台的 CMake 预设
          case "${{ matrix.os }}" in
            macos-latest) PRESET="macos-release" ;;
            windows-latest) PRESET="win-release" ;;
            ubuntu-latest) PRESET="linux-release" ;;
          esac
          # 无工程则跳过
          if [ ${#PROJECTS[@]} -eq 0 ]; then
            echo "未识别到任何 dayN 工程，跳过构建！"
            exit 0
          fi
          # 循环构建每个工程
          for proj in "${PROJECTS[@]}"; do
            echo -e "\n==================== 构建工程：$proj ===================="
            # 创建独立构建目录
            mkdir -p build/$proj-build
            # 配置项目 CMake（复用 Qt 环境）
            cmake --preset=$PRESET -S $proj -B build/$proj-build
            # 并行构建
            cmake --build build/$proj-build --config Release --parallel $(nproc 2>/dev/null || echo 4)
            echo "==================== 工程 $proj 构建完成 ===================="
          done

      # 10. 运行所有工程（验证可用性）
      - name: 运行工程（Linux/macOS）
        if: matrix.os != 'windows-latest'
        shell: bash
        run: |
          PROJECTS=(${GITHUB_ENV#*PROJECTS=})
          if [ ${#PROJECTS[@]} -eq 0 ]; then exit 0; fi
          for proj in "${PROJECTS[@]}"; do
            echo -e "\n==================== 运行工程：$proj ===================="
            EXEC_PATH="./build/$proj-build/Release/${proj^}"  # day0 -> Day0
            if [ -f "$EXEC_PATH" ]; then
              chmod +x $EXEC_PATH
              $EXEC_PATH || echo "工程 $proj 运行失败（非致命错误）"
            else
              echo "工程 $proj 可执行文件未找到：$EXEC_PATH"
            fi
          done

      - name: 运行工程（Windows）
        if: matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          $envProjects = $env:PROJECTS
          $PROJECTS = $envProjects -split ' ' | Where-Object { $_ -ne '' }
          if ($PROJECTS.Count -eq 0) { exit 0; }
          foreach ($proj in $PROJECTS) {
            Write-Host "`n==================== 运行工程：$proj ===================="
            $EXEC_PATH = ".\build\$proj-build\Release\$($proj.ToUpper()).exe"  # day0 -> DAY0.exe
            if (Test-Path $EXEC_PATH) {
              & $EXEC_PATH
              if ($LASTEXITCODE -ne 0) {
                Write-Warning "工程 $proj 运行失败（非致命错误）"
              }
            } else {
              Write-Warning "工程 $proj 可执行文件未找到：$EXEC_PATH"
            }
          }
