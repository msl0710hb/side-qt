name: Qt 6.9.2 官方安装器 CI（side-qt 极速版）
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build-and-run:
    strategy:
      fail-fast: false
      matrix:
        os: [macos-latest, windows-latest, ubuntu-latest]
        include:
          - os: macos-latest
            exec_suffix: ""
            cxx_flags: "-stdlib=libc++"
          - os: windows-latest
            exec_suffix: .exe
            cxx_flags: ""
          - os: ubuntu-latest
            exec_suffix: ""
            cxx_flags: "-ldl -lpthread"
    runs-on: ${{ matrix.os }}

    steps:
      # 1. 检出源码
      - name: 检出项目源代码
        uses: actions/checkout@v4

      # 2. 安装系统依赖（仅需 ninja，Qt 由 Action 自带）
      - name: 安装依赖（Ubuntu）
        if: matrix.os == 'ubuntu-latest'
        run: sudo apt-get update && sudo apt-get install -y ninja-build
      - name: 安装依赖（macOS）
        if: matrix.os == 'macos-latest'
        run: brew install ninja
      - name: 安装依赖（Windows）
        if: matrix.os == 'windows-latest'
        run: choco install ninja

      # 3. 一键安装 Qt 6.9.2（含缓存，Linux 需指定 linux_gcc_64）
      - name: 安装 Qt 6.9.2
        uses: jurplel/install-qt-action@v4
        with:
          version: '6.9.2'
          target: 'desktop'
          arch: ${{ matrix.os == 'ubuntu-latest' && 'linux_gcc_64' ||
                    matrix.os == 'macos-latest'   && 'clang_64'       ||
                    matrix.os == 'windows-latest' && 'win64_msvc2022_64' }}
          cache: true
          install-deps: ${{ matrix.os == 'ubuntu-latest' }}

      # 4. 自动识别 dayN 工程（忽略 day1、day2）
      - name: 自动识别 dayN 工程
        id: find_projects
        shell: bash
        run: |
          if [[ ${{ matrix.os }} == "windows-latest" ]]; then
            PROJECTS=$(powershell -Command "(Get-ChildItem -Directory -Filter 'day[0-9]*' | Where-Object { $_.Name -notin 'day1', 'day2' } | Sort-Object { [int]($_.Name -replace 'day', '') }).Name -join ' '")
          else
            PROJECTS=$(find . -maxdepth 1 -type d -name "day[0-9]*" | sed 's|^\./||' | grep -vE '^day1$|^day2$' | sort -V | tr '\n' ' ' | sed 's/ $//')
          fi
          echo "PROJECTS=$PROJECTS" >> $GITHUB_ENV

      # 5. 批量构建 dayN 工程
      - name: 批量构建 dayN 工程（Linux/macOS）
        if: matrix.os != 'windows-latest' && env.PROJECTS != ''
        shell: bash
        run: |
          IFS=' ' read -r -a arr <<< "$PROJECTS"
          for proj in "${arr[@]}"; do
            echo "==== 构建 $proj ===="
            cmake -S "$proj" -B "build/$proj-build" \
              -GNinja -DCMAKE_BUILD_TYPE=Release \
              -DCMAKE_CXX_STANDARD=17 \
              -DCMAKE_CXX_FLAGS="${{ matrix.cxx_flags }}"
            cmake --build "build/$proj-build" --parallel $(nproc 2>/dev/null || echo 4)
          done

      - name: 批量构建 dayN 工程（Windows）
        if: matrix.os == 'windows-latest' && env.PROJECTS != ''
        shell: pwsh
        run: |
          foreach ($proj in ($env:PROJECTS -split ' ')) {
            Write-Host "==== 构建 $proj ===="
            cmake -S "$proj" -B "build/$proj-build" -GNinja -DCMAKE_BUILD_TYPE=Release
            cmake --build "build/$proj-build" --parallel $(Get-CimInstance Win32_Processor).NumberOfLogicalProcessors
          }

      # 6. 批量运行 dayN 工程
      - name: 批量运行 dayN 工程（Linux/macOS）
        if: matrix.os != 'windows-latest' && env.PROJECTS != ''
        shell: bash
        run: |
          IFS=' ' read -r -a arr <<< "$PROJECTS"
          for proj in "${arr[@]}"; do
            EXEC_NAME=$(echo "$proj" | sed 's/^./\U&/')
            FIND_PERM=$([[ "$(uname)" == "Linux" ]] && echo "/111" || echo "+111")
            EXEC=$(find "build/$proj-build" -type f -perm "$FIND_PERM" -name "$EXEC_NAME${{ matrix.exec_suffix }}" | head -n1)
            [[ -f "$EXEC" ]] && LD_LIBRARY_PATH="${Qt6_DIR}/../.." "$EXEC" || echo "未找到可执行文件"
          done

      - name: 批量运行 dayN 工程（Windows）
        if: matrix.os == 'windows-latest' && env.PROJECTS != ''
        shell: pwsh
        run: |
          foreach ($proj in ($env:PROJECTS -split ' ')) {
            $execName = $proj.ToUpper()
            $exec = Get-ChildItem -Path "build/$proj-build" -Filter "$execName${{ matrix.exec_suffix }}" -Recurse -File | Select-Object -First 1 -ExpandProperty FullName
            if ($exec) { & $exec }
          }